; --- General -----------------------------------------------------------------

general_prolog name
// --------------------------------------------------
procedure {name};
asm

general_epilog
end;

ropsize 'Rel opsize
  1

ropsize 'Imm '8
  1

ropsize 'Imm '16
  2

ropsize 'Imm '32
  4

ropsize 'Reg opsize
  1

ropsize 'RegInd opsize
  1

ropsize 'RegIndDispl opsize
  2

ropsize 'Direct opsize
  4

ropsize 'Indirect opsize
  1

ropsize 'IndirectDispl opsize
  5

ropsize 'ShortImm opsize
  1

ropsize 'IndirectShortDispl opsize
  2

; --- Arithmetic Instructions -------------------------------------------------

calcRightOpAddr '1Op addrR opsize
  lea esi, [ebx + SingleOpDispl]

calcRightOpAddr '2Op addrR opsize
  lea esi, [ebx + SourceOpDispl]

calcRA 'Imm write opsize

calcRA 'Reg write opsize
  xor eax, eax
  mov al, [esi]
  lea esi, [eax * 4 + RegistersFile]

calcRA 'RegInd write opsize
  xor eax, eax
  mov al, [esi]
  mov al, [eax * 4 + RegistersFile]
  lea esi, [eax * 4 + RegistersFile]

calcRA 'RegIndDispl write opsize
  xor eax, eax
  mov al, [esi]
  mov al, [eax * 4 + RegistersFile]
  add al, [esi + 1]
  lea esi, [eax * 4 + RegistersFile]

calcRA 'Direct write opsize
  mov eax, [esi]
  mov edx, {ropsize|Imm|{opsize}}
  call GetCellAddr{write}
  mov esi, eax

calcRA 'Indirect write opsize
  xor eax, eax
  mov al, [esi]
  mov eax, [eax * 4 + RegistersFile]
  mov edx, {ropsize|Imm|{opsize}}
  call GetCellAddr{write}
  mov esi, eax

calcRA 'IndirectDispl write opsize
  xor eax, eax
  mov al, [esi]
  mov eax, [eax * 4 + RegistersFile]
  mov esi, [esi + 1]
  add eax, esi
  mov edx, {ropsize|Imm|{opsize}}
  call GetCellAddr{write}
  mov esi, eax

calcRA 'ShortImm write opsize

calcRA 'IndirectShortDispl write opsize
  xor eax, eax
  mov al, [esi]
  mov eax, [eax * 4 + RegistersFile]
  movsx esi, byte ptr [esi + 1]
  add eax, esi
  mov edx, {ropsize|Imm|{opsize}}
  call GetCellAddr{write}
  mov esi, eax

calcLA 'Reg
  lea edi, [ebx + DestOpDispl]
  xor eax, eax
  mov al, [edi]
  lea edi, [eax * 4 + RegistersFile]

calcLA 'RegInd
  lea edi, [ebx + DestOpDispl]
  xor eax, eax
  mov al, [edi]
  mov al, [eax * 4 + RegistersFile]
  lea edi, [eax * 4 + RegistersFile]

fetchS addrR '32
  mov eax, [esi]

fetchS addrR '16
  mov ax, [esi]

fetchS addrR '8
  mov al, [esi]

fetchS 'ShortImm '32
  movsx eax, byte ptr [esi]

fetchS 'ShortImm '16
  movsx ax, byte ptr [esi]

setFlagsZCN
  pushfd
  pop Flags

reg_A '32
eax

reg_A '16
ax

reg_A '8
al

ptr_mod '32

ptr_mod '16
word ptr

ptr_mod '8
byte ptr

fetchR addrR size
mov {reg_A|{size}}, [esi]

fetchR 'ShortImm size
movsx {reg_A|{size}}, byte ptr [esi]

fetchR 'ShortImm '8
mov {reg_A|8}, [esi]

perform_arith_2op addrR size 'left operation
  {fetchR|{addrR}|{size}}
  {operation} [edi], {reg_A|{size}}

perform_arith_2op addrR size 'right operation
  mov {reg_A|{size}}, [edi]
  {operation} [esi], {reg_A|{size}}

perform_arith_1op size operation
  {operation} {ptr_mod|{size}} [esi]

advanceIP_1op addrR opsize
  add _IP, 2+{ropsize|{addrR}|{opsize}}

advanceIP_2op addrR addrL opsize
  add _IP, 3+{ropsize|{addrR}|{opsize}}

arith_instruction_2op operation addrR addrL direction size 'def
{general_prolog|{operation}_{addrL}_{addrR}_{direction}_{size}}
  {calcRightOpAddr|2Op|{addrR}|{size}}
  {calcRA|{addrR}||{size}}
  {calcLA|{addrL}}
  {perform_arith_2op|{addrR}|{size}|{direction}|{operation}}
  {setFlagsZCN}
  {advanceIP_2op|{addrR}|{addrL}|{size}}
{general_epilog}

arith_instruction_1op operation addrR size 'def
{general_prolog|{operation}_{addrR}_{size}}
  {calcRightOpAddr|1Op|{addrR}|{size}}
  {calcRA|{addrR}|Write|{size}}
  {perform_arith_1op|{size}|{operation}}
  {setFlagsZCN}
  call CommitCellWrite
  {advanceIP_1op|{addrR}|{size}}
{general_epilog}

arith operation '1op opcode
{expand_arith_addrR|{operation}||1op|{opcode}}

arith operation '2op opcode
{expand_arith_addrR|{operation}|left|2op|{opcode}}
{expand_arith_addrR|{operation}|right|2op|{opcode}}

expand_arith_addrR operation 'left '2op opcode
{expand_arith_size|{operation}|Imm|left|2op|{opcode}}
{expand_arith_size|{operation}|Reg|left|2op|{opcode}}
{expand_arith_size|{operation}|RegInd|left|2op|{opcode}}
{expand_arith_size|{operation}|RegIndDispl|left|2op|{opcode}}
{expand_arith_size|{operation}|Direct|left|2op|{opcode}}
{expand_arith_size|{operation}|Indirect|left|2op|{opcode}}
{expand_arith_size|{operation}|IndirectDispl|left|2op|{opcode}}
{expand_arith_size|{operation}|ShortImm|left|2op|{opcode}}
{expand_arith_size|{operation}|IndirectShortDispl|left|2op|{opcode}}

expand_arith_addrR operation 'right '2op opcode
{expand_arith_size|{operation}|Reg|right|2op|{opcode}}
{expand_arith_size|{operation}|RegInd|right|2op|{opcode}}
{expand_arith_size|{operation}|RegIndDispl|right|2op|{opcode}}
{expand_arith_size|{operation}|Direct|right|2op|{opcode}}
{expand_arith_size|{operation}|Indirect|right|2op|{opcode}}
{expand_arith_size|{operation}|IndirectDispl|right|2op|{opcode}}
{expand_arith_size|{operation}|IndirectShortDispl|right|2op|{opcode}}

expand_arith_addrR operation direction '1op opcode
{expand_arith_size|{operation}|Reg||1op|{opcode}}
{expand_arith_size|{operation}|RegInd||1op|{opcode}}
{expand_arith_size|{operation}|RegIndDispl||1op|{opcode}}
{expand_arith_size|{operation}|Direct||1op|{opcode}}
{expand_arith_size|{operation}|Indirect||1op|{opcode}}
{expand_arith_size|{operation}|IndirectDispl||1op|{opcode}}
{expand_arith_size|{operation}|IndirectShortDispl||1op|{opcode}}

expand_arith_size operation addrR direction opcount opcode
{expand_arith|{opcount}|{operation}|{addrR}|{direction}|32|{opcode}}
{expand_arith|{opcount}|{operation}|{addrR}|{direction}|16|{opcode}}
{expand_arith|{opcount}|{operation}|{addrR}|{direction}|8|{opcode}}

expand_arith '1op operation addrR direction size opcode
{arith_instruction_1op|{operation}|{addrR}|{size}|{opcode}}

expand_arith '2op operation addrR direction size opcode
{arith_instruction_2op|{operation}|{addrR}|Reg|{direction}|{size}|{opcode}}
{arith_instruction_2op|{operation}|{addrR}|RegInd|{direction}|{size}|{opcode}}

; --- Flow Control Instructions -----------------------------------------------

branch_to_target 'Rel
  mov esi, _IP
  mov eax, esi
  inc eax
  mov edx, 1
  call GetCellAddr
  movsx eax, byte ptr [eax]
  add esi, eax
  mov _IP, esi

branch_to_target addrR
  {calcRightOpAddr|1Op|{addrR}|32}
  {calcRA|{addrR}||32}
  {fetchS|{addrR}|32}
  mov _IP, eax

branch_code_size addrR
  2

branch_code_size 'Rel
  1

check_cond flag neg
  test Flags, {flag}
  j{neg}z @@dont_branch

check_cond '- neg

branch_instr_size addrR
{branch_code_size|{addrR}}+{ropsize|{addrR}|32}

store_ret_addr operation addrR

store_ret_addr 'call addrR
  sub _SP, 4
  mov eax, _SP
  mov edx, 4
  call GetCellAddrWrite
  mov esi, eax
  mov eax, _IP
  add eax, {branch_instr_size|{addrR}}
  mov [esi], eax
  call CommitCellWrite

advanceIP_branch '- addrR

advanceIP_branch flag addrR
@@dont_branch:
  add _IP, {branch_instr_size|{addrR}}

branch_instruction_rel operation flag neg 'def
{branch_instruction|{operation}|Rel|{flag}|{neg}|def}

branch_instruction_abs operation addrR flag neg 'def
{branch_instruction|{operation}|{addrR}|{flag}|{neg}|def}

branch_instruction operation addrR flag neg 'def
{general_prolog|{operation}_{addrR}}
  {check_cond|{flag}|{neg}}
  {store_ret_addr|{operation}|{addrR}}
  {branch_to_target|{addrR}}
  ret
  {advanceIP_branch|{flag}|{addrR}}
{general_epilog}

branch_rel oper 'def
{branch_instruction_rel|{oper}|-||def}

branch_abs oper opcode
{branch_instruction_abs|{oper}|Imm|-||{opcode}}
{branch_instruction_abs|{oper}|Reg|-||{opcode}}
{branch_instruction_abs|{oper}|RegInd|-||{opcode}}
{branch_instruction_abs|{oper}|RegIndDispl|-||{opcode}}
{branch_instruction_abs|{oper}|Direct|-||{opcode}}
{branch_instruction_abs|{oper}|Indirect|-||{opcode}}
{branch_instruction_abs|{oper}|IndirectDispl|-||{opcode}}
{branch_instruction_abs|{oper}|IndirectShortDispl|-||{opcode}}

branch_cond oper flag neg opcode
{branch_instruction_rel|{oper}|{flag}|{neg}|{opcode}}

; --- Opcodes -----------------------------------------------------------------

opc_addrR n/a
  0

opc_addrR 'Imm
  $0

opc_addrR 'Reg
  $1

opc_addrR 'RegInd
  $2

opc_addrR 'RegIndDispl
  $3

opc_addrR 'Direct
  $4

opc_addrR 'Indirect
  $5

opc_addrR 'IndirectDispl
  $6

opc_addrR 'Rel
  $7

opc_addrR 'ShortImm
  $8

opc_addrR 'IndirectShortDispl
  $E

opc_addrL n/a
  0

opc_addrL 'Reg
  $00

opc_addrL 'RegInd
  $10

opc_size n/a
  0

opc_size '32
  $00

opc_size '16
  $40

opc_size '8
  $80

opc_dir n/a
  0

opc_dir 'left
  $00

opc_dir 'right
  $20

build_opcode opcode addrR addrL direction size
  {opcode} shl 8 or {opc_addrR|{addrR}} or {opc_addrL|{addrL}} or {opc_size|{size}} or {opc_dir|{direction}}

itable_put_single name opcode
  InstructionTable[{opcode}] := @{name};

itable_put_bulk name opcode
  for i := 0 to $FF do
    InstructionTable[{opcode} shl 8 + i] := @{name};

arith_instruction_2op operation addrR addrL direction size opcode
  {itable_put_single|{operation}_{addrL}_{addrR}_{direction}_{size}|{build_opcode|{opcode}|{addrR}|{addrL}|{direction}|{size}}}

arith_instruction_1op operation addrR size opcode
  {itable_put_single|{operation}_{addrR}_{size}|{build_opcode|{opcode}|{addrR}|||{size}}}

branch_instruction_rel operation flag neg opcode

branch_instruction_abs operation addrR flag neg opcode
  {itable_put_single|{operation}_{addrR}|{build_opcode|{opcode}|{addrR}|||}}

branch_rel operation opcode
  {itable_put_bulk|{operation}_Rel|{opcode}}

; --- Target ------------------------------------------------------------------

target
unit Instructions;
interface
procedure InitInstructionTable;
implementation
uses Core, Memory, Registers;
const
  SourceOpDispl = 3;
  DestOpDispl = 2;
  SingleOpDispl = 2;
{arith|add|2op|def}
{arith|adc|2op|def}
{arith|sub|2op|def}
{arith|sbb|2op|def}
{arith|cmp|2op|def}
{arith|and|2op|def}
{arith|or|2op|def}
{arith|xor|2op|def}
{arith|not|1op|def}
{arith|neg|1op|def}
{arith|inc|1op|def}
{arith|dec|1op|def}
{arith|mov|2op|def}
{branch_rel|jmp|def}
{branch_abs|jmp|def}
{branch_rel|call|def}
{branch_abs|call|def}
{branch_cond|jz|ZFlag||def}
{branch_cond|jnz|ZFlag|n|def}
{branch_cond|jc|CFlag||def}
{branch_cond|jnc|CFlag|n|def}
{branch_cond|jn|NFlag||def}
{branch_cond|jp|NFlag|n|def}
procedure InitInstructionTable;
var i : Integer;
begin
  {arith|add|2op|$01}
  {arith|adc|2op|$02}
  {arith|sub|2op|$03}
  {arith|sbb|2op|$04}
  {arith|cmp|2op|$05}
  {arith|and|2op|$07}
  {arith|or|2op|$08}
  {arith|xor|2op|$09}
  {arith|not|1op|$0A}
  {arith|neg|1op|$0B}
  {arith|inc|1op|$0C}
  {arith|dec|1op|$0D}
  {arith|mov|2op|$A0}
  {branch_rel|jmp|$80}
  {branch_abs|jmp|$81}
  {branch_rel|call|$82}
  {branch_abs|call|$83}
  {branch_rel|jz|$88}
  {branch_rel|jnz|$89}
  {branch_rel|jc|$8A}
  {branch_rel|jnc|$8B}
  {branch_rel|jn|$8C}
  {branch_rel|jp|$8D}
end;
end.

